import { parseSetCookieHeader } from "../../http/util";
import { fromReadableStream } from "../../utils/stream";
import { debug } from "../../adapters/logger";
import { convertToQuery } from "../../core/routing/util";
import { extractHostFromHeaders, removeUndefinedFromQuery } from "./utils";
// Not sure which one is really needed as this is not documented anywhere but server actions redirect are not working without this,
// it causes a 500 error from cloudfront itself with a 'x-amzErrortype: InternalFailure' header
const CloudFrontBlacklistedHeaders = [
    "connection",
    "expect",
    "keep-alive",
    "proxy-authenticate",
    "proxy-authorization",
    "proxy-connection",
    "trailer",
    "upgrade",
    "x-accel-buffering",
    "x-accel-charset",
    "x-accel-limit-rate",
    "x-accel-redirect",
    /x-amz-cf-(.*)/,
    /x-amzn-(.*)/,
    /x-edge-(.*)/,
    "x-cache",
    "x-forwarded-proto",
    "x-real-ip",
    "set-cookie",
    "age",
    "via",
];
function normalizeAPIGatewayProxyEventV2Body(event) {
    const { body, isBase64Encoded } = event;
    if (Buffer.isBuffer(body)) {
        return body;
    }
    if (typeof body === "string") {
        return Buffer.from(body, isBase64Encoded ? "base64" : "utf8");
    }
    if (typeof body === "object") {
        return Buffer.from(JSON.stringify(body));
    }
    return Buffer.from("", "utf8");
}
function normalizeAPIGatewayProxyEventV2Headers(event) {
    const { headers: rawHeaders, cookies } = event;
    const headers = {};
    if (Array.isArray(cookies)) {
        headers.cookie = cookies.join("; ");
    }
    if (rawHeaders) {
        for (const [key, value] of Object.entries(rawHeaders)) {
            headers[key.toLowerCase()] = value;
        }
    }
    return headers;
}
async function convertFromAPIGatewayProxyEventV2(event) {
    const { rawPath, rawQueryString, requestContext } = event;
    const headers = normalizeAPIGatewayProxyEventV2Headers(event);
    return {
        type: "core",
        method: requestContext.http.method,
        rawPath,
        url: `https://${extractHostFromHeaders(headers)}${rawPath}${rawQueryString ? `?${rawQueryString}` : ""}`,
        body: normalizeAPIGatewayProxyEventV2Body(event),
        headers,
        remoteAddress: requestContext.http.sourceIp,
        query: removeUndefinedFromQuery(convertToQuery(rawQueryString)),
        cookies: event.cookies?.reduce((acc, cur) => {
            const [key, value] = cur.split("=");
            acc[key] = value;
            return acc;
        }, {}) ?? {},
    };
}
async function convertToApiGatewayProxyResultV2(result) {
    const headers = {};
    Object.entries(result.headers)
        .map(([key, value]) => [key.toLowerCase(), value])
        .filter(([key]) => !CloudFrontBlacklistedHeaders.some((header) => typeof header === "string" ? header === key : header.test(key)))
        .forEach(([key, value]) => {
        if (value === null || value === undefined) {
            headers[key] = "";
            return;
        }
        headers[key] = Array.isArray(value) ? value.join(", ") : `${value}`;
    });
    const body = await fromReadableStream(result.body, result.isBase64Encoded);
    const response = {
        statusCode: result.statusCode,
        headers,
        cookies: parseSetCookieHeader(result.headers["set-cookie"]),
        body,
        isBase64Encoded: result.isBase64Encoded,
    };
    debug(response);
    return response;
}
export default {
    convertFrom: convertFromAPIGatewayProxyEventV2,
    convertTo: convertToApiGatewayProxyResultV2,
    name: "aws-apigw-v2",
};
